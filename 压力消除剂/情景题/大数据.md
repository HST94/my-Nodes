###   对42亿个qq号码进行排序

> qq号的位数小于13位，存储着42亿QQ号的内存不得超过600MB

#### 位图排序

  由于待排序的数据记录较多，我们单纯地使用常见的排序方法时间效率较低，运行时间会很长。而且内存空间有限（限制为1MB左右），所以我们不能同时把所有整数读入内存（如果每个整数使用7个字节来存储，那么1MB内存空间只能存大约143000个数字）。当然我们可以多次读取输入文件，多次排序，但是更好的方案是使用位图排序，可以使用有限的1MB内存空间并只进行一趟排序。

* 根据待排序集合中最大的数，开辟一个位数组，用来表示待排序集合中的整数；
* 待排序集合中的数字在位数组中的对应位置置1，其他的置0；
* 例如，待排序集合{1,2,3,5,8,13}可以表示为：0-1-1-1-0-1-0-0-1-0-0-0-0-1
* 这样排序过程自然可以分为三步：
  * 第一步：将所有的位都置为0；
  * 第二步：通过读入文件中的每个整数，将每个对应的位都置为1；
  * 第三步：检验每一位，如果该位为1，输出对应的整数。

注意：位图排序是使用一个二进制位而不是一个整数来表示0或1，这样可以大大地减少所需要的内存空间。使用位图排序的前提是要知道待排序序列中的最大数。位图排序的缺点是有些数没有出现过，仍要为其保留一个位。故位图排序比较适合关键字密集的序列，例如一个QQ号码。





### 腾讯面试题：给40亿个不重复的unsigned int的整数，没排过序的，然后再给一个数，如何快速判断这个数是否在那40亿个数当中？

 

#### 方案1：

* 申请512M的内存，一个bit位代表一个unsigned int值。读入40亿个数，设置相应的bit位，读入要查询的数，查看相应bit位是否为1，为1表示存在，为0表示不存在。

 

#### 方案2：

* 因为2^32为40亿多，所以给定一个数可能在，也可能不在其中；这里我们把40亿个数中的每一个用32位的二进制来表示。假设这40亿个数开始放在一个文件中。

* 然后将这40亿个数分成两类:
  * 1.最高位为0
  * 2.最高位为1
  
  * 并将这两类分别写入到两个文件中，其中一个文件中数的个数<=20亿，而另一个>=20亿（这相当于折半了）；与要查找的数的最高位比较并接着进入相应的文件再查找
    * 再然后把这个文件为又分成两类:
      1.次最高位为0
      2.次最高位为1

并将这两类分别写入到两个文件中，其中一个文件中数的个数<=10亿，而另一个>=10亿（这相当于折半了）； 与要查找的数的次最高位比较并接着进入相应的文件再查找。
    .......
以此类推，就可以找到了,而且时间复杂度为O(logn)。





### 在2.5亿个整数中找出不重复的整数，注，内存不足以容纳这2.5亿个整数

* 采用2-Bitmap（每个数分配2bit，00表示不存在，01表示出现一次，10表示多次，11无意义）进行，共需内存2^32 * 2 bit=1 GB内存，还可以接受。然后扫描这2.5亿个整数，查看Bitmap中相对应位，**如果是00变01，01变10，10保持不变。所描完事后，查看bitmap，把对应位是01的整数输出即可。**
  



### 海量数据处理-从10亿个数中找频率最高的1000个数

* 分治+Trie树/hash+小顶堆（就是上面提到的最小堆）
  * 将数据集按照Hash方法分解成多个小数据集
  * 使用Trie树或者Hash统计每个小数据集中的query词频
  * 用小顶堆求出每个数据集中出现频率最高的前K个数，最后在所有top K中求出最终的top K。