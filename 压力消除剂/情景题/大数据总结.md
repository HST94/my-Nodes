### 海量日志数据，提取出某日访问百度次数最多的那个IP。

* 注意到IP是32位的，最多有个2^32个 IP。可以采用映射的方法，比如模1000，把整个大文件映射为1000个小文件
* 找出每个小文件中出现频率最大的IP（可以采用hash_map进行频率统计，然后再找出频率最大的几个）及相应的频率。
* 在这1000个最大的IP中，找出那个频率最大的IP，即为所求。

### 请你统计最热门的10个查询串，要求使用的内存不能超过1G。

> 搜索引擎会通过日志文件把用户每次检索使用的所有检索串都记录下来，每个查询串的长度为1-255字节。
>
> 假设目前有一千万个记录（这些查询串的重复度比较高，虽然总数是1千万，但如果除去重复后，不超过3百万个。一个查询串的重复度越高，说明查询它的用户越多，也就是越热门。）

* 先对这批海量数据预处理，在O（N）的时间内用Hash表完成排序
* 借助堆这个数据结构，找出Top K
  * 维护一个K(该题目中是10)大小的小根堆，然后遍历300万的Query，分别和根元素进行对比

### 有一个1G大小的一个文件，里面每一行是一个词，词的大小不超过16字节，内存限制大小是1M。返回频数最高的100个词。

* 顺序读文件中，对于每个词x，取hash(x)%5000，然后按照该值存到5000个小文件（记为x0,x1,...x4999）中。这样每个文件大概是200k左右。
  * 如果其中的有的文件超过了1M大小，还可以按照类似的方法继续往下分，直到分解得到的小文件的大小都不超过1M
* 对每个小文件，统计每个文件中出现的词以及相应的频率（可以采用trie树/hash_map等），并**取出出现频率最大的100个词（可以用含100个结点的最小堆）**
* 把100个词及相应的频率存入文件，得到了5000个文件。下一步就是把这5000个文件进行归并（类似与归并排序）的过程（先取每个文件的第一个词频，排序得到一个文件，下一次取下一个，重复该步骤）



### 有10个文件，每个文件1G，每个文件的每一行存放的都是用户的query，每个文件的query都可能重复。要求你按照query的频度排序。

* 顺序读取10个文件，按照hash(query)%10的结果将query写入到另外10个文件，新生成的文件每个的大小大约也1G（假设 hash函数是随机的）
* 找一台内存在2G左右的机器，依次对用hash_map(query, query_count)来统计每个query出现的次数。利用快速/堆/归并排序按照出现次数进行排序。

* 将排序好的query和对应的 query_cout输出到文件中。这样得到了10个排好序的文件
* 对这10个文件进行归并排序（内排序与外排序相结合）



### 给定a、b两个文件，各存放50亿个url，每个url各占64字节，内存限制是4G，让你找出a、b文件共同的url？

> 可以估计每个文件安的大小为5G×64=320G，远远大于内存限制的4G。所以不可能将其完全加载到内存中处理。考虑采取分而治之的方法。

* 遍历文件a，对每个url求取hash(url)%1000，然后根据所取得的值将url分别存储到1000个小文件（记为a0,a1,...,a999）中。这样每个小文件的大约为300M。
* 遍历文件b，采取和a相同的方式将url分别存储到1000小文件（记为b0,b1,...,b999）。这样处理后，所有可能相同的url都在对应的小文件（a0vsb0,a1vsb1,...,a999vsb999）中，不对应的小文件不可能有相同的url。然后我们只要求出1000对小文件中相同的url即可。

* 求每对小文件中相同的url时，可以把其中一个小文件的url存储到hash_set中。然后遍历另一个小文件的每个url，看其是否在刚才构建的hash_set中，如果是，那么就是共同的url，存到文件里面就可以了。

### 在2.5亿个整数中找出不重复的整数，注，内存不足以容纳这2.5亿个整数。

#### 方案1：2-bitmap

* 个数分配2bit，00表示不存在，01表示出现一次，10表示多次，11无意义
* 扫描这2.5亿个整数，查看Bitmap中相对应位，如果是00变01，01变10，10保持不变。所描完事后，查看bitmap，把对应位是01的整数输出即可

#### 方案2

* 进行划分小文件的方法。然后在小文件中找出不重复的整数，并排序。然后再进行归并，注意去除重复的元素。

### 给40亿个不重复的unsigned int的整数，没排过序的，然后再给一个数，如何快速判断这个数是否在那40亿个数当中？

#### 方案1：bitmap

* 申请512M的内存，一个bit位代表一个unsigned int值。读入40亿个数，设置相应的bit位，读入要查询的数，查看相应bit位是否为1，为1表示存在，为0表示不存在。

* 然后将这40亿个数分成两类: 1.最高位为0 2.最高位为1，将这两类分别写入到两个文件中，其中一个文件中数的个数<=20亿，而另一个>=20亿（这相当于折半了）；与要查找的数的最高位比较并接着进入相应的文件再查找
* 再然后把这个文件为又分成两类: 1.次最高位为0 2.次最高位为1
* 并将这两类分别写入到两个文件中，其中一个文件中数的个数<=10亿，而另一个>=10亿（这相当于折半了）； 与要查找的数的次最高位比较并接着进入相应的文件再查找。 ....... 以此类推，就可以找到了,而且时间复杂度为O(logn)，方案2完。

### 怎么在海量数据中找出重复次数最多的一个？

* 先做hash，然后求模映射为小文件，求出每个小文件中重复次数最多的一个，并记录重复次数。然后找出上一步求出的数据中重复次数最多的一个就是所求

### 上千万或上亿数据（有重复），统计其中出现次数最多的前N个数据。

* 上千万或上亿的数据，现在的机器的内存应该能存下。所以考虑采用hash_map/搜索二叉树/红黑树等来进行统计次数。然后就是取出前N个出现次数最多的数据了，可以用第2题提到的堆机制完成。

### 一个文本文件，大约有一万行，每行一个词，要求统计出其中最频繁出现的前10个词，请给出思想，给出时间复杂度分析。

* 这题是考虑时间效率。用trie树统计每个词出现的次数，时间复杂度是O(n*le)（le表示单词的平准长度）。*
* *然后是找出出现最频繁的前10个词，可以用堆来实现，前面的题中已经讲到了，时间复杂度是O(n*lg10)。所以总的时间复杂度，是O(n*le)与O(n*lg10)中较大的哪一个。

