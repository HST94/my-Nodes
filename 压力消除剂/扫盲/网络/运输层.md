### 为什么说TCP是面向流的协议？而UDP是面向数据报的协议？

#### TCP是流式传输协议

* TCP并不关心单次传输多少数据，实际上由于网络设备的影响，也会发生将一次tcp传输拆解为多次，或者多次tcp传输合并为一次的情况（粘包），所以在TCP层面上长度是没有意义的。

#### TCP没有长度字段

* 基于TCP是面向字节流传输，传输数据受当前网络环境（拥塞、接收方窗口）影响，会产生粘包拆包现象，由于应用层数据被拆分成多个包发送，所以长度这个字段对于TCP来说是没有意义的

TCP协议有一个缓冲区，发送数据时先将数据存储在缓冲区，然后tcp协议按照与服务器约定的滑动窗口的大小从缓冲区取数据发送，**取数据时应用层无法控制**，并且取完后还需要等待确认后才可以将数据从缓冲区删除掉，**输数据受当前网络环境（拥塞、接收方窗口）影响**，一段来自应用层的数据，可能会被拆分成多段，或者和其他来自应用层的数据整合在一个报文段被发送（粘包分包），**TCP面向流是为TCP可靠传输服务**

UDP是没有缓冲区的，当你发送数据时，**直接将你的数据加上UDP的头发送**，不需要确认，这个时候如果负载数据过大，就会在IP层出现分片。

#### TCP/UDP的区别

* 基于连接与无连接

* 对系统资源的要求（TCP较多，UDP少）；

* UDP程序结构较简单；

* 流模式与数据报模式 ；

* TCP保证数据正确性，UDP可能丢包；

* TCP保证数据顺序，UDP不保证。

#### 各自的运用

| 应用                         | 应用层协议/端口                                              | 传输协议 |
| ---------------------------- | ------------------------------------------------------------ | -------- |
| 电子邮件/简单邮件传输协议    | SMTP/25                                                      | TCP      |
| * 远程终端访问               | Telnet/23                                                    | TCP      |
| Web                          | HTTP/80 HTTPs/443                                            | TCP      |
| 文件传输                     | FTP/20/21                                                    | TCP      |
| 远程文件服务器               | NFS                                                          | 通常UDP  |
| 流式多媒体/因特网电话        |                                                              | UDP/TCP  |
| 网络管理（简单网络管理协议） | SNMP/该协议提供了**监控网络设备**的方法， 以及配置管理,统计信息收集,性能管理及安全管理等； | UDP      |
| 域名解析                     | DNS/53                                                       | UDP      |
| 网络控制信息协议（Ping）     | ICMP                                                         | UDP      |
| 邮件读取协议                 | POP3                                                         |          |
| 动态主机配置协议             | DHCP67/78/服务器控制一段lP地址范围，客户机登录服务器时就可以自动获得服务器分配的**lP地址和子网掩码** |          |




### 粘包、拆包、分包

#### 背景

##### 滑动窗口

TCP流量控制主要使用滑动窗口协议，在TCP的**窗口**字段中，接收方告诉发送方自己所能接收的数据大小（取决于当前接收方的可用接收窗口大小），从而达到发送方根据窗口字段控制发送数据大小，达到流量控制的目的。

* 基于流量控制机制下的TCP协议，是面向字节流传输的，从而报文会被拆分或合并

##### MSS

* Maximum Segement Size ： 最大报文长度，是OSI五层模型中传输层的最大发送字段规模

##### MTU

* Maximum Segement Size：最大传输单元，**链路层一次可发送数据的大小**
* MSS根据MTU计算而得，当发送数据满足MSS，必然满足MTU

* 当数据包大于MTU，就会发生**分片**
  * IP数据报中的标识，标志，片偏移就是用来描述分片的
    * 同一数据报的分片标识相同，最后一个分片标志为0，其他都是1

#### 粘包拆包的原因

* 发送的数据大于TCP发送缓冲区的大小，拆包
* 待发送数据大于MSS（最大报文长度），拆包
* 发送数据小于TCP缓冲区的大小，TCP将多次写入缓冲区的数据一起发送（多包合并）
* 接收端应用层没有及时读取窗口（缓冲区的数据，将会发生粘包）

#### 分包/粘包拆包的解决方法

* 发送端给每个数据包添加包首部，首部中应该至少包含数据包的长度，这样接收端在接收到数据后，通过读取包首部的长度字段，便知道每一个数据包的实际长度了。
* 发送端将每个数据包**封装为固定长度（不够的可以通过补0填充）**，这样接收端每次从接收缓冲区中读取固定长度的数据就自然而然的把每个数据包拆分开来。
* 可以在数据包之间**设置边界**，如添加特殊符号，这样，接收端通过这个边界就可以将不同的数据包拆分开。





### 四次挥手中，接收方TIME_WAIT的作用

客户端收到服务的释放连接的请求后，不是立马进入CLOSE状态，而是**还要再等待2MSL。**

- **确保最后一个确认报文能够到达**。如果没能到达，服务端就会会重发FIN请求释放连接。等待一段时间没有收到重发就说明服务的已经CLOSE了。如果有重发，则客户端再发送一次LAST ack信号

- **等待一段时间是为了让本连接持续时间内所产生的所有报文都从网络中消失，使得下一个新的连接不会出现旧的连接请求报文**



### 三次握手中，第二次握手丢失如何处理

* 三次握手协议中，服务器维护一个**未连接队列**，该队列为每个客户端的SYN包开设一个条目，该条目表明服务器已收到SYN包，并向客户发出确认，正在等待客户的确认包。这些条目所标识的连接在**服务器处于 SYN_RECV状态**，当服务器收到客户的确认包时，删除该条目，服务器进入ESTABLISHED状态。
* 服务器发送完SYN－ACK包，如果未收到客户确认包，**服务器进行首次重传**，等待一段时间仍未收到客户确认包，进行第二次重传，**如果重传次数超过系统规定的最大重传次数，系统将该连接信息从半连接队列中删除。**
* **半连接存活时间**是指半连接队列的条目存活的最长时间，也即服务器从收到SYN包到确认这个报文无效的最长时间，该时间值是所有重传请求包的最长等待时间总和。有时我们也称半连接存活时间为Timeout时间、SYN_RECV存活时间。

#### 为什么不两次握手？

> 双方都需要确认对方收到自己的起始序列号

* 为了实现可靠数据传输， TCP 协议的通信双方， **都必须维护一个序列号**， 以标识发送出去的数据包中， 哪些是已经被对方收到的。 三次握手的过程即是通信双方相互告知序列号起始值， 并确认对方已经收到了序列号起始值的必经步骤

* 如果只是两次握手， 至多只有连接发起方的起始序列号能被确认， 另一方选择的序列号则得不到确认
* 防止已失效的连接请求又传送到服务器端，因而产生错误

#### 

### SYN洪泛攻击原理及防御

* 攻击者发送大量的SYN报文段，而不完成第三次握手的步骤，服务器不断为这种半开连接分配资源，导致服务器的连接资源被消耗殆尽

#### 预防

##### SYN Cookie

* 当服务器收到一个SYN报文段时，不知道是否为攻击报文，于是**不会为该请求分配一个半开连接**
* 服务器生成一个初始TCP序列号，该序列号是**SYN报文段的源和目的IP地址与端口号以及仅有服务器知道的秘密数的一个复杂函数（散列函数），称为Cookie**
* 服务端发送这种带有`cookie（一个特殊序列号）`的SYNACK分组（服务器并不记忆该cookie或任何有关SYN状态信息）
* 如果客户是合法的，将返回一个ACK报文段（第三次握手），当服务器收到ACK后，需要验证该ACK和前面发送的某些SYN相对应
  * 当然服务器并没有相关状态记忆，客户端收到SYNACK后，**返回ACK时确认字段中的值等于SYNACK字段，也就是`cookie`的值加1**
  * 服务器将使用使用ACK报文中的源和目的IP地址与端口号以及秘密数**运行相同的散列函数**，如果结果+1等于ACK报文的确认号，服务器认为该ACK对应于较早的SYN报文段，是合法的
  * 此时服务器生成一个具有套接字的全开连接
* 如果客户没有返回ACK报文，要么是攻击，要么是丢失或不想连接，此时服务端不处理，也没有分配资源

##### 降低SYN TIMEOUT时间

> 使得服务端尽快释放半连接占用的资源

##### 拦截

> 短时间收到某个IP的重复SYN请求，就认为受到攻击

