### 请你说一说用户态和内核态区别

用户态和内核态是操作系统的两种运行级别，两者最大的区别就是特权级不同。

* 用户态拥有最低的特权级，内核态拥有较高的特权级。运行在用户态的程序不能直接访问操作系统内核数据结构和程序。内核态和用户态之间的转换方式主要包括：**系统调用，异常和中断。**
* 只能受限于访问内存，且不允许访问外围设备
* 内核态，或者说CPU的特权模式，是CPU的一种工作状态，它影响CPU对不同指令的执行结果。**操作系统通过跟CPU配合，设置特权模式和用户模式，来防止应用程序进行越权的操作**
  * 可以访问内存所有数据，包括外围设备、硬盘、网卡
* **防止应用程序越权访问内存时使用了虚拟地址空间映射的技术，这是操作系统软件配合硬件的MMU共同实现的。**
* 在用户模式下，应用程序访问的内存地址是虚拟内存地址，会映射到操作系统指定的物理地址上。这个虚拟内存地址空间就是你说的用户空间。
* **应用程序无法自由进入内核态，只能通过操作系统提供的接口调用进入，或者在硬件中断到来时被动进入**
* 应用程序通过操作系统功能来使用硬件



### 互斥锁/自旋锁/条件变量/读写锁

#### 互斥锁

* **无法获取锁时，进线程立刻放弃剩余的时间片并进入阻塞（或者说挂起）状态，同时保存寄存器和程序计数器的内容（保存现场，上下文切换的前半部分）**，当可以获取锁时，进线程激活，等待被调度进CPU并恢复现场（上下文切换下半部分）上下文切换会带来数十微秒的开销，不要在性能敏感的地方用互斥锁

#### 读写锁

* 写锁被占用时，所有申请读锁和写锁的进线程都会被阻塞，读锁被占用时，申请写锁的进线程被阻塞，其他申请读锁的进线程不会。

#### 自旋锁

* 如果进线程无法取得锁，进线程不会立刻放弃CPU时间片，**而是一直申请CPU时间片轮询自旋锁，直到获取为止**，一般应用于加锁时间很短（1ms左右或更低）的场景。

#### 条件变量

* **不是锁**, 但是条件变量能够阻塞线程, **调用阻塞函数开始阻塞**
  * 使用条件变量+互斥量
    * 互斥量: 保护一块共享数据----> 保护数据
    * 条件变量: 引起阻塞, 生产者和消费者模型----> 阻塞线程
*  条件变量的两个动作
  * 条件不满足: 阻塞线程
  * **条件满足: 通知阻塞的线程开始工作**

### 孤儿进程/僵尸进程

* **孤儿进程：**
  * 父进程没有调用wait()就终止，子进程变成为了孤儿进程。
  * **孤儿进程后期会被系统的 init 进程（init进程是Linux/UNIX系统内所有用户进程的父进程/根进程）接管，并定期调用 wait()，以便收集任何孤儿进程的退出状态，并释放[孤儿进程标识符]和[进程表条目]。对系统并无危害。**

* **僵尸进程：**
  * 当一个进程终止时，操作系统会释放其资源，但是**它位于进程表中的条目依然存在**，直到它的父进程调用wait()。**在进程已经终止但其父进程尚未调用wait()，这样的进程称为僵尸进程**
  * 所有进程终止都会过渡到僵尸进程状态，一般是短暂存在的，一旦父进程调用wait()，僵尸进程的进程标识符和它在进程表中的条目就会被释放。
  * **僵尸进程无法被系统有效的回收**
  * ps 查看时状态为 Z 的即为僵尸进程，或 top命令可直接看到 zombie 的个数。
  * 僵尸进程的父进程此时一定仍在运行，产生僵尸进程的元凶其实是他们的父进程，**杀掉父进程，僵尸进程就变为了孤儿进程，便可以转交给 init 进程回收处理。**



### 三种I/O设备与主机信息传送的控制方式

* **程序查询方式**
  * **CPU通过程序轮询I/O设备是否准备就绪**，从而控制I/O设备与主机交换信息。
  * 采用这种方式实现主机与I/O设备交换信息，**要求I/O接口类设置一个能反映I/O设备是否准备就绪的状态标记，CPU通过对此标记的检测，可得知I/O设备的准备情况。**
  * **只要一启动I/O设备，CPU轮询I/O设备的准备情况，从而中止了原程序的执行。**CPU在反复的查询过程中，犹如原地踏步。另一方面，I/O设备准备就绪后，CPU要一个字一个字地从I/O设备取出，经CPU送至主存，此刻CPU也不能执行原程序，**这种方式使CPU和I/O设备处于穿行工作状态，CPU的效率不高。**

* **程序中断方式**
  * **当I/O设备准备就绪并向CPU发出中断请求后才予以响应，这将大大提高CPU的工作效率。**
  * 采用这种方式，CPU和I/O接口不仅在硬件方面需要增加相应的电路，而且在软件方面还必须编制中断服务程序。
  * **CPU在相应中断请求后，必须停止现行程序而转入中断服务程序，并且为了完成I/O设备与主存交换信息，还必须占用CPU内部的寄存器，消耗CPU的资源。**

* **直接存储器（DMA）方式**
  * 主存与I/O设备间有一条数据通路，主存和I/O设备交换信息时，无需调用中断服务程序。**若出现DMA和CPU同时访问主存，CPU总是将总线占有权让给DMA，通常把DMA的这种占有称为窃取或挪用。**
  * 窃取的时间一般为一个存取周期，故又把DMA占用的存取周期称为窃取周期或挪用周期。而且，在DMA窃取存取周期时，CPU尚能继续做内部操作（不需要访存的操作，如乘法运算）。





### 进程间通信——共享内存（Shared Memory）

* [进程间通信——共享内存（Shared Memory）](https://blog.csdn.net/ypt523/article/details/79958188?depth_1-utm_source=distribute.pc_relevant.none-task&utm_source=distribute.pc_relevant.none-task)





### select , poll, epoll 区别

> [select、poll、epoll之间的区别(搜狗面试)](https://www.cnblogs.com/aspirant/p/9166944.html)